package com.jonathandoolittle.foobar;

/**
 * 
 * My second level 3 challenge from Google Foobar!
 * 
 * In this challenge, I was tasked with finding the security checksum for a 
 * line of workers. We took down a worker, but realized it would be detected 
 * during the automated review. In order to avoid being caught, this program 
 * generates what the checksum should be so we can trick the system.
 * 
 * <pre> 
 *    Solution.solution(0, 3);
 * </pre>
 *
 * @author Jonathan Doolittle
 * @version 0.1 - Oct 20, 2021
 *
 */
public class Solution {
	
	// ******************************
	// Public methods
	// ******************************
	
	/**
	 * Finds the security checksum to avoid detecting during an automated review!
	 * The security checksum is generated by taking the ID's of all but the last worker
	 * in the first line, then all but the last 2 in the second line, and so on. All of 
	 * the id values are then XOR'd to get the final value.
	 * @param start The ID of the first member in line
	 * @param length The total number of workers a checkpoint line can hold at once
	 * @return The security checksum
	 */
	public static int solution(int start, int length) {

		int result = start;
		boolean isFirstElement = true;
		
		/* Because one item is always being left off, the length
		 * of our line will always be length+1. In the problem 
		 * statement, the lines are represented as a matrix, but
		 * we don't actually need to store the values, just XOR them.
		 */
		for(int i = 0; i < length; i++) {
			for(int j = 0; j < length+1; j++) {
				if(j < length-i) {
					
					// Skip the first value, because we set result to equal it already
					if(isFirstElement) {
						isFirstElement = false;
					} else {
						// XOR each item
						result ^= (i*length) + j + start;
					}
					
				}
			}
		}
		
		return result;
	}
	
	/**
	 * Test drive our solution
	 */
	public static void main(String[] args) {
		System.out.println(solution(0, 3));
	}
	
}